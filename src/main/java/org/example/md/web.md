### 常见的Http状态码有哪些？

- 1xx：信息，服务器收到请求，需要请求者继续执行操作
    - 100 Continue：继续，客户端应继续其请求
    - 101 Switching Protocols：切换协议，服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议
- 2xx：成功，操作被成功接收并处理
    - 200 OK：请求成功。一般用于GET和POST请求
    - 201 Created：已创建。成功请求并创建了新的资源
    - 204 No Content：无内容。服务器成功处理了请求，但在返回的响应中不包含内容
- 3xx：重定向，需要进一步的操作以完成请求
    - 301 Moved Permanently：永久移动。请求的资源已被永久移动到新位置
    - 302 Found：临时移动。请求的资源临时被移动了
    - 304 Not Modified：未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源(可以使用客户端缓存内容)
- 4xx：客户端错误，请求包含语法错误或无法完成请求
    - 400 Bad Request：客户端请求的语法错误，服务器无法理解
    - 401 Unauthorized：请求要求用户的身份认证
    - 403 Forbidden：服务器理解请求客户端的请求，但是拒绝执行此请求
    - 404 Not Found：服务器无法根据客户端的请求找到资源（网页）
- 5xx：服务器错误，服务器在处理请求的过程中发生了错误
    - 500 Internal Server Error：服务器内部错误，无法完成请求
    - 501 Not Implemented：服务器不支持请求的功能，无法完成请求
    - 503 Service Unavailable：由于超载或系统维护，服务器暂时无法处理客户端的请求
    - 504 Gateway Timeout：网关超时，服务器作为网关或代理，但是没有及时从上游服务器收到请求

### Http请求包含哪些内容，请求头和请求体有哪些类型?

Http请求包含`请求头`、`请求行`和`请求体`。  
常见的请求头类型:

- General headers: 同时适用于请求和响应消息，但与最终消息传输的数据无关的消息头。
- Request Headers: 包含更多有关要获取的资源或客户端本身信息的消息头。
- Entity Headers：包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。

请求体的类型一般有：

- 表单（form-data）application/x-www-form-urlencoded，提交表单数据
- 多部分数据（Multipart data）multipart/form-data 用于上传文件或复杂表单数据
- JSON application/json
- XML application/xml
- 纯文本 text/plain

### Http中 GET 和 POST 的区别是什么?

|        | GET            | POST              |
|--------|----------------|-------------------|
| 数据传输方式 | 通过URL传递数据      | 通过请求体传递数据         |
| 数据大小   | 有大小限制，一般为2KB   | 没有大小限制            |
| 安全性    | 不安全，数据会显示在URL中 | 安全性较高，数据不会显示在URL中 |
| 幂等性    | 幂等             | 非幂等               |
| 可缓存性   | 可缓存            | 不可缓存              |
| 请求参数类型 | 只能发送ASCII字符    | 可以发送任何类型的数据       |
| 应用场景   | 获取数据，查询数据      | 提交数据，修改数据         |

**ps:幂等性指的是就是一次请求和多次请求同一个资源产生相同的结果。**

---

### Http1.0 和 Http2.0 有什么区别?

|       |        http1.0        |             http2.0              |
|:-----:|:---------------------:|:--------------------------------:|
| 连接方式  | 非持久连接(每次亲求都要单独建立TCP)  |               持久连接               |
|  请求头  |    每次请求都会携带完整的请求头     |       请求头压缩，只发送一次，后续请求头复用        |
| 传输效率  | 传输效率低，每次请求都会携带完整的请求头  | (二进制文件)传输效率高，请求头压缩，只发送一次，后续请求头复用 |
| 多路复用  | 不支持多路复用，每次请求都需要建立新的连接 |     支持多路复用，多个请求可以同时在一个连接上传输      |
| 服务器推送 |       不支持服务器推送        |        支持服务器推送(服务器可以推送资源)        |

### Http2.0 和 3.0 有什么区别?

|       |         http2.0          |              http3.0               |
|:-----:|:------------------------:|:----------------------------------:|
|  协议   |  基于TCP，使用`二进制分帧层`实现多路复用  | 基于UDP，使用 `QUIC协议`，提供类似TCP的可靠性和多路复用 |
| 安全角度  |   使用TLS(Https)加密，安全性较高   |     默认使用QUIC自带的`TLS 1.3`，加密为强制     |
| 连接建立  | TCP三次握手 + TLS握手，建立连接需要时间 | `QUIC协议` 集成了`建立连接`和`加密握手` ,连接建立速度快 |
| 解决的问题 | TCP队头阻塞（仍存在，在高延迟和丢包情况下）  |         通过QUIC协议避免TCP队头阻塞          |

**队头阻塞：一个连接同时只能有效地承载一个请求**  
HTTP/1.1 是一个纯文本协议，它只在有效荷载（payload）的前面附加头（headers），
在资源块（resource chunks）之间不使用分隔符。它不会进一步区分单个资源与其他资源。
HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的串行队列。

**http2.0的队头阻塞:** 使用 SPDY协议 作为 HTTP/2 的起点，并使用多路复用（单个连接上可以进行并行交错的请求和响应，之间互不干扰），
解决了队头阻塞的问题，不过 TCP 本身的队头阻塞是无法避免的，而且对其影响更大 ，因为多个同域名的请求都只会使用同一个 TCP
连接，不会有多个并行连接

### Https 和 Http 的区别是什么?

|       |      http      |        https        |
|:-----:|:--------------:|:-------------------:|
|  端口   |    默认端口是80     |      默认端口是443       |
|  协议   |      明文传输      | 加密传输 （SSL / TLS 协议） |
|  安全性  | 不安全，数据会显示在URL中 |  安全性较高，数据不会显示在URL中  |
|  协议   |     基于TCP      |      基于TCP+TLS      |
| SEO影响 |    降低展示位置排名    |        优先展示         |

---

### TCP 和 UDP 有什么区别？（简单）

|        |       TCP        |      UDP       |
|:------:|:----------------:|:--------------:|
|  连接性   |       面向连接       |      无连接       |
|  顺序保证  |     保证数据包的顺序     |   不保证数据包的顺序    |
|  可靠性   |    保证数据包的可靠性     |   不保证数据包的可靠性   |
|  头部大小  |   头部较大，至少20字节    |   头部较小，只有8字节   |
|   性能   |      低、延迟大       |     高、延迟小      |
| 数据传输模式 |     字节流传输模式      |    数据报传输模式     |
|  适用场景  | 文件传输、web浏览、邮件发送等 | 视频会议、直播、DNS查询等 |

### 说说 TCP 的三次握手？（简单）

三次握手是为了建立可靠的TCP连接，三次握手的过程如下：

1. 客户端发送一个 SYN（同步）包到服务器，表示客户端请求建立连接。
2. 服务器收到 SYN 包后，发送一个 SYN-ACK（同步-确认）包到客户端，表示服务器同意建立连接。
3. 客户端收到 SYN-ACK 包后，发送一个 ACK（确认）包到服务器，表示客户端已经收到服务器的确认。

- 过程：客户端 打招呼 “你好”， 服务端回应 “你好”， 客户端确认 “收到”

**为什么需要三次握手**

1. 为了防止历史重复连接的初始化（主要原因）
2. 为了同步客户端和服务端的序列号（次要原因）

### TCP 是用来解决什么问题？（简单）

TCP 是一个可靠的、面向连接的协议，它提供了数据传输的可靠性、顺序性和完整性。解决了**数据在不可靠的IP网络上的传输问题**

1. TCP 通过三次握手建立连接，确保双方都准备好进行数据传输。(连接管理)
2. TCP 使用序列号和确认号来确保数据包的顺序和完整性。(可靠性)
3. TCP 使用滑动窗口机制来控制数据的发送和接收速度，避免拥塞。(流量控制)
4. TCP 通过拥塞避免算法来防止网络过载。（拥塞控制）

---

### 说说 TCP 的四次挥手？（简单）

四次挥手的目的：是为了保证数据的完整性，一次 FIN + ACK 代表一方结束数据传输，两次则是互相结束数据传输  
四次挥手是为了关闭TCP连接，四次挥手的过程如下：

1. 客户端发送一个 FIN（终止）包到服务器，表示客户端请求关闭连接。
2. 服务器收到 FIN 包后，发送一个 ACK（确认）包到客户端，表示服务器已经收到客户端的关闭请求。
3. 服务器发送一个 FIN 包到客户端，表示服务器也请求关闭连接。
4. 客户端收到 FIN 包后，发送一个 ACK 包到服务器，表示客户端已经收到服务器的关闭请求。

- 过程：客户端说 “再见”， 服务端回应 “你要走了吗？”， 服务端说 “你真的要走了吗？”， 客户端回应 “是的，我真的走了”

**可能存在三次挥手：** 当服务器 没有数据 发送给 客户端的时候，他就会把 FIN + ACK 一起发送给客户端

### TCP 的粘包和拆包能说说吗？（中等）

TCP 是一个流协议，它将数据视为无边界的数据流，而不是数据包。因此，TCP 无法直接区分数据包的边界，这可能导致粘包和拆包的问题。

**粘包：** 当两个或多个数据包被合并为一个数据包发送时，就会发生粘包。例如，如果客户端发送了两个数据包，服务器可能会将它们合并为一个数据包接收。

**拆包：** 当一个数据包被拆分为多个数据包发送时，就会发生拆包。例如，如果客户端发送了一个较大的数据包，服务器可能会将其拆分为多个较小的数据包接收。

**解决方法：**

1. 在数据包的前面添加长度字段，以便接收方可以知道每个数据包的长度，从而正确地解析数据包。
2. 使用特殊的分隔符来标记数据包的边界，以便接收方可以正确地解析数据包。

**PS:TCP是流传输，不管是粘包还是拆包，主要都是和`发送缓冲区`的大小有关系**

### 说说 TCP 拥塞控制的步骤？（简单）

TCP 拥塞控制是一种用于防止网络过载的机制，它通过调整发送速率来控制网络流量。TCP 拥塞控制的主要步骤如下：

1. 慢启动：TCP 连接开始时，发送速率从 1 MSS（最大报文段大小）开始，然后指数级增长，直到达到一个阈值（ssthresh）。
2. 拥塞避免：当发送速率达到 阈值（ssthresh） 时，发送速率线性增长，直到发生拥塞。
3. 快速重传：当接收方收到一个失序的数据包时，它会立即发送一个重复的确认包，以通知发送方有数据包丢失。发送方收到重复的确认包后，会立即重传丢失的数据包，而不是等待超时。
4. 快速恢复：当发送方收到重复的确认包时，它会将 ssthresh 减半，然后重新进入拥塞避免阶段。

---

### TCP/IP 四层模型是什么?

TCP/IP 四层模型是一种网络协议模型，它将网络协议分为四层，从下到上分别是：

1. 链路层：负责在物理网络中传输数据，例如以太网、Wi-Fi 等。
2. 网络层：负责在网络上传输数据包，例如 IP 协议。
3. 传输层：负责在主机之间传输数据，例如 TCP、UDP 协议。
4. 应用层：负责处理应用程序之间的通信，例如 HTTP、FTP、SMTP 等。

### Cookie、Session、Token 之间有什么区别？

|      |      Cookie      |       Session        |          Token          |
|:----:|:----------------:|:--------------------:|:-----------------------:|
| 存储位置 |     客户端（浏览器）     |         服务器端         |        客户端（浏览器）         |
| 安全性  |   不安全，容易被劫持和篡改   |    安全性较高，存储在服务器端     |      安全性较高，存储在客户端       |
| 生命周期 |  默认情况下，浏览器关闭时失效  |    默认情况下，服务器关闭时失效    |    默认情况下，Token 过期时失效    |
| 适用场景 | 主要用客户端的用户简单存储和追踪 | 服务器复杂状态管理（需要存大量会话数据） | 用于无状态认证和授权、特别在分布式和跨域情况下 |

### 从网络角度来看，用户从输入网址到网页显示，期间发生了什么？

1. **解析URL** ：浏览器首先解析用户输入的URL，将其分解为协议、域名、端口、路径、查询参数和锚点等部分。
2. **DNS解析** ：浏览器通过DNS解析将域名解析为IP地址，以便与服务器建立连接。
3. **建立TCP连接** ：浏览器与服务器建立TCP连接，使用三次握手协议。
4. **封装IP**：在TCP包上封装 源IP 和 目标IP
5. **封装MAC**：在IP包上添加 源MAC 和 目标MAC
6. **发送数据** ：浏览器将HTTP请求封装成TCP包，并通过网络发送到服务器。(其中会经过网卡、交换机、路由器，再做层层校验)
7. **服务器处理请求** ：服务器接收到HTTP请求后，解析请求内容，并返回相应的HTTP响应。
8. 浏览器接收数据并渲染

### 线程和进程有什么区别？

|      |            线程             |             进程              |
|:----:|:-------------------------:|:---------------------------:|
|  定义  | 线程是进程中的一个执行单元，是CPU调度的基本单位 |   进程是操作系统分配资源的基本单位，是线程的容器   |
| 生命周期 |   线程的生命周期较短，通常在几毫秒到几秒之间   | 进程的生命周期较长，从创建到销毁可能需要几分钟到几小时 |
| 资源占用 |         线程共享进程的资源         |          进程拥有独立的资源          |
| 通信方式 |     线程之间可以通过共享内存进行通信      | 进程之间可以通过管道、消息队列、共享内存等方式进行通信 |
| 优先级  |     线程的优先级可以在运行时动态调整      |  进程的优先级通常在创建时设置，运行时无法动态调整   |
| 依赖关系 |        线程依赖于其所在的进程        |       进程之间相互独立，没有依赖关系       |
| 互斥性  | 线程之间可以共享资源，但需要同步机制来避免竞争条件 | 进程之间不能共享资源，需要通过进程间通信机制来共享数据 |

### 进程之间的通信方式有哪些？

进程之间的通信方式主要有以下几种：

1. **管道（Pipe）**：管道是一种半双工的通信方式，数据只能在一个方向上流动。管道分为匿名管道和命名管道。
    - 匿名管道只能用于具有亲缘关系的进程之间通信
    - 命名管道可以在没有亲缘关系的进程之间通信
2. **消息队列（Message Queue）**：消息队列是一种用于进程间通信的机制，它允许进程发送和接收消息。消息队列可以用于实现异步通信，也可以用于实现同步通信。
3. **共享内存（Shared Memory）**：共享内存是一种用于进程间通信的机制，它允许进程共享一块内存空间。共享内存可以用于实现高速的进程间通信，但是需要同步机制来避免竞争条件。
4. **信号量（Semaphore）**：信号量是一种用于进程间同步的机制，它允许进程在访问共享资源之前进行互斥访问。信号量可以用于实现进程间的同步和互斥。
5. **信号（Signal）**：信号是一种用于进程间通信的机制，它允许进程发送和接收信号。信号可以用于实现进程间的异步通信，也可以用于实现进程间的同步和互斥。
6. **套接字（Socket）**：套接字是一种用于进程间通信的机制，它允许进程在网络中发送和接收数据。套接字可以用于实现进程间的网络通信，也可以用于实现进程间的本地通信。
7. **文件（File）**：文件是一种用于进程间通信的机制，它允许进程读写文件。文件可以用于实现进程间的数据共享

### 进程的调度算法你知道吗？
进程调度算法是操作系统用于决定哪个进程应该被分配 CPU 资源以执行的一组规则。以下是一些常见的进程调度算法：
1. **先来先服务（FCFS）**：按照进程到达的顺序来分配 CPU 资源。这种算法简单易实现，但是可能会导致长进程饥饿。
2. **短作业优先（SJF）**：根据进程的执行时间来分配 CPU 资源。这种算法可以最小化平均等待时间，但是可能会导致短进程饥饿。
3. **优先级调度**：根据进程的优先级来分配 CPU 资源。这种算法可以优先执行高优先级的进程，但是可能会导致低优先级的进程饥饿。
4. **时间片轮转（RR）**：将 CPU 时间划分为固定长度的时间片，然后按照进程到达的顺序来分配时间片。这种算法可以公平地分配 CPU 资源，但是可能会导致进程切换的开销。
5. **多级反馈队列（MLFQ）**：将进程分为多个队列，每个队列具有不同的优先级。进程可以在队列之间移动，根据其优先级和执行时间来分配 CPU 资源。这种算法可以平衡响应时间和吞吐量。
7. **最高响应比优先（HRRN）**：通过计算响应比来决定下一个被调度的进程，适合在批处理中平衡长短任务的等待时间