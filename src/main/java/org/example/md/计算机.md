### I/O模型有哪些？
- 阻塞I/O（Block I/O）：调用I/O操作时，如果数据没有准备好，调用进程会被阻塞，直到数据准备好为止。
- 非阻塞I/O（Non-Block I/O）：调用I/O操作时，如果数据没有准备好，调用进程不会被阻塞，而是立即返回一个错误码，进程可以继续执行其他操作。
- I/O多路复用（I/O Multiplexing）：通过一个线程来同时监听多个I/O操作，当某个I/O操作准备好时，通知相应的进程进行处理。
- 信号驱动I/O（Signal Driven I/O）：调用I/O操作时，进程会注册一个信号处理函数，当I/O操作准备好时，系统会发送一个信号通知进程进行处理。
- 异步I/O（Asynchronous I/O）：调用I/O操作时，进程不会等待I/O操作完成，而是立即返回，当I/O操作完成时，系统会通知进程进行处理。

### Select、Poll、Epoll 之间有什么区别？
- Select：每次调用select时，都需要将所有需要监听的文件描述符传递给内核，内核会遍历这些文件描述符，检查是否有数据可读或可写。
当有数据可读或可写时，内核会将这些文件描述符添加到就绪列表中，然后返回给a用户进程。用户进程需要再次调用select来获取就绪列表中的文件描述符
  - 通常描述符数量为1024
- Poll：与select类似，但是poll使用了一个数组来保存需要监听的文件描述符
  - 动态数组存储
  - 每次调用仍然需要遍历全部描述符
- Epoll：epoll使用了一个红黑树来保存需要监听的文件描述符，当有数据可读或可写时，内核会将这些文件描述符添加到一个就绪队列中，然后返回给用户进程。
用户进程只需要调用epoll_wait来获取就绪队列中的文件描述符，而不需要再次遍历全部描述符。
  - 提供**边缘触发(ET)**和**水平触发(LT)** 两种模式 
    - ET模式：当文件描述符上有数据可读时，内核只会通知一次，用户进程需要一次性读取完所有数据，否则下次不会通知
    - LT模式：当文件描述符上有数据可读时，内核会一直通知，直到用户进程读取完所有数据
  - 内核会维护一个就绪队列，用户进程只需要调用epoll_wait来获取就绪队列中的文件描述符，而不需要再次遍历全部描述符
  

### 为什么网络 I/O 会被阻塞？
1. **等待数据（还没发送出去 或则 数据还没到达）**：当网络 I/O 操作需要从网络上读取数据时，如果数据还没有到达，那么调用进程会被阻塞，直到数据到达为止（或 数据未能及时发出去，发送操作可能是堵塞的）。
2. **系统资源有限**： 当系统资源有限时，例如内存不足或者 CPU 负载过高，可能会导致网络 I/O 操作被阻塞。
3. **本身是阻塞的行为**： 大多数网络API默认情况下是堵塞的，例如 `send` 和 `accept`。


