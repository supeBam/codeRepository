### MySQL 的存储引擎有哪些？它们之间有什么区别？

- InnoDB
- MyISAM
- Memory(数据存储再内存中)
- NDB(大规模分布式应用)
- ...

首先在MySQL5.5.5之后存储引擎默认为InnoDB。

InnoDB 与 MyISAM 的区别

1. **InnoDB支持事务，MyISAM不支持** <br>
   因为第一点特性，MyISAM不适合高并发场景，比较适合查询和插入为主的应用。<br>
   所以:
    - MyISAM适合OLAP(Online AnalyticalProcessing-联机分析处理)，例如数据仓库，博客等。 <br>
    - InnoDB适合OLTP(Online Transaction Processing-联机事务处理)，例如电商，银行等。
2. **InnoDB支持外键，MyISAM不支持** <br>
   因为外键性能较差，所以一般项目不会使用外键，而是使用业务逻辑代码做限制。
3. **InnoDB支持行级锁，MyISAM支持表级锁** <br>
    - InnoDB在没有使用主键作为where条件时，也会锁全表。
4. MyISAM的数据和索引是分开存储的，索引也是压缩的 <br>
    - 他们的索引都是B+树，InnoDB的B+树的叶子节点存储了完整的行数据，MyISAM的索引和数据是分开存储的

### MySQL InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别？

**聚簇索引**

- 表中聚簇索引只能有一个，一般为主键索引
- 主键索引的叶子节点存储了完整的行数据
- 适用于范围查找 （叶子节点中存放了所有的数据，且叶子节点之间是通过双向链表连接的）

**非聚簇索引**

- 表中可以有多个非聚簇索引，一般由普通索引和唯一索引组成
- 非聚簇索引的叶子节点存储了*主键*的值以及所在的*列*值
- 适合快速查找特定的列 （索引中存储了列值）

拓展：B+树，在InnoDB中，默认的实现方式为B+树，叶子节点存储了完整的行数据，而MyISAM的B+树叶子节点存储的是数据的地址。<br>

为什么需要使用B+树呢？ <br>
推理过程文章原文：<https://cloud.tencent.com/developer/article/1681803>
推理过程：

1. 当我们查询数据发现查询结果顺序并不是由按照插入顺序决定的，而是根据主键进行了排序。排序的目的是为了当我们根据主键查询时，
   按照顺序查到需要的结果后，不需要继续往后查询了。
2. 执行某个查询SQL不可能把查询记录一条条的使用IO操作，应该一次性把数据全部放进内存中。MySQL在其中引入了**页**，
   数据都存放在页的数据行中，MySQL中一页的大小为16KB。
3. 为了快速找到准确的页，设计了类似**书签**的标记。
   例如：假设每100页数据插入一个标签，当需要查第3456页就知道在第34个标签那。

MySQL 页结构讲解可以看看：
<https://www.bilibili.com/video/BV1pG4y1o7n3/?spm_id_from=333.337.search-card.all.click&vd_source=d40e64c746feefc8c24cdf263d809fa3>

### MySQL的索引类型

从数据结构来看，可以分为：

- B+树索引
    - MySQL默认的索引类型，树型结构，叶子节点双向链表，可以范围查询
- Hash索引
    - 哈希表结构，查询速度快，不支持范围查询，且不存储数据顺序
- R树索引
    - 适用于空间查询，常用于存储GIS系统的空间数据
- 倒排索引
    - 用于存储单词与文档之间的映射关系，可以模糊匹配和关键字搜索

从InnoDB存储引擎的索引类型来看，可以分为：

- 聚簇索引
    - 叶子节点存储了完整的行数据
- 非聚簇索引
    - 叶子节点存储了主键的值以及所在的列值。可以有多个

从索引性质来看，可以分为：

- 主键索引
    - 表中的主键索引只能有一个，不能为null
- 普通索引
    - 索引值可以重复，且可以有多个
- 唯一索引
    - 索引值唯一，但索引值可以有多个null
- 联合索引
    - 多个列组成的索引，联合索引的查询顺序与索引列的顺序有关
- 全文索引
    - 用于全文搜索，适用于对文本内容进行复杂的查询
- 空间索引
    - 适用于多维数据查询，例如区域查询和最近距离查询

### 为什么MySQL选择使用B+树作为索引结构？

数据库中B+树的特点：

- B+树是一棵多叉树，随着数据量的变大，树的高度增长速度不会像其他二叉树一样那么快，维持了比较矮且胖的性质。
  非叶子节点存储的都是**索引**和**页指针**，使得页的空间更大，可以存储更多的记录。
- B+树是一棵自平衡树，根节点到各个叶子节点的长度相同，并且在插入和删除的时候会进行分裂和合并操作，维持树的平衡。
  他又会有冗余节点，使得在删除的时候让树结构变化小。
- B+树叶子节点之间是通过双向链表连接的，可以快速进行范围查询。

### B树和B+树的区别

- 相同点
    - 他们都是平衡树，且都为多叉树
- 不同点
    - B树
        - 每个节点都存的都是完整的数据
        - 因为数据都在各个节点中，当范围查找时，每次都需要从根遍历
        - B树查询时间不稳定，因为数据在某个节点上
    - B+树
        - 非叶子节点存储的是索引和页指针，叶子节点存储了完整的数据（因此内存中可以存放更多的索引页）
        - 因为数据都在叶子节点上，且叶子节点是双向链表连接。范围查找效率更快
        - 查询时间稳定、平均。因为数据都在叶子节点上，需要从根查到叶

### 为什么InnoDB B+树中同层的非叶子节点之间也存在双链表? （拓展）

执行一个sql语句

```sql
select *
from table
where a < index1
  and index1 < b
  and index2 > c
  and index2 < d;
-- 这段sql里有两个独立索引，一个index1，一个index2 
```

**问题一：MySQL会选择使用哪个索引呢？**<br>
结论：哪个索引区分大，筛选更快就用哪个。假如使用 index1 能选出 n 条记录，使用 index2 能选出 m 条记录，如果 n <
m，则使用index1<br><br>
**问题二：MySQL是怎么判断 n < m 呢？** <br>
假设 n 和 m 分别代表叶子节点的数，正常来想应该是找到第一个值所在的叶子节点，然后向后遍历 n 次。但是如果n和m数据量较大，这样比较费时。
假设 n < m， 我们都知道每个数据页自己有多少个数据，假设每个数据页有 avg 个数据。他们分别用了 y1、y2 个数据页。
那么 n = y1 * avg， m = y2 * avg，数据页其实可以估算大小，假设 n、m 数据量非常大。假设有 k 层，可以从k-1获取页数或则更上层。
这样就可以加载更少的节点来推算n、m的大小了，这也是为什么同层的非叶子节点是双向链表<br>
原文来自：<https://www.zhihu.com/question/478187330/answer/2050494617>

### MySQL 三层 B+ 树能存多少数据？

MySQL的InnoDB中，默认数据页大小为 **16KB** <br>
**基本参数**<br>
每个非叶子节点里只存储了**指针**和**索引值**，假设每个数据记录的主键和数据大小总共为 **1KB**(实际更小)，
每个叶节点的大小为16KB<br><br>
**计算**

- 叶子节点：每个叶子节点可以存放 **16** 条记录 (16 KB / 1 KB )
- 第二层：每个指针的大小为 **6字节**，索引键为 **8字节**，所以每个节点可以存放 **1170** 个叶子节点 (16 * 1024 / (6 + 8) )
- 根节点：每个节点可以有**1170**个子节点
- 总记录数：叶子节点 * 第二层节点 * 根节点 = 1170 * 1170 * 16 = 21902400 （约等于2千万条）

ps：默认一页大小为16KB，可以通过 `innodb_page_size` 修改大小。操作系统中有`连续读`和`缓冲数据`
的原理，所以进行IO读取时，会连续的读取4KB的数据，所以页大小通常设为4,8,16KB(4的倍数)

### MySQL 索引的最左前缀匹配原则是什么？

最左前缀匹配原则是指在创建联合索引时，索引的顺序与查询条件中的列的顺序一致，
且查询条件中的列必须包含联合索引中的最左边的列。顺序由左到右，依此类推。

**原理：** 联合索引在B+树中是按照索引列的顺序进行排序的，所以最左前缀匹配原则可以有效地利用索引，提高查询效率。

**索引下推：** 在MySQL5.6以后推出索引下推，他是一种可以减少回表的技术，用于`联合索引`上，它可以把一些查询条件下推到引擎层完成判断。不再像之前
那样，先查到数据，再回到Sever层进行判断。

```mysql
# 索引下推index(a,b,c)
select a, b, c
from table
where a = 1
  and c = 3
``` 

**MySQL8.0.13新特性：**在使用联合索引时，当a的基数较小时，他会自己补全a的查询条件，这样就符合最左匹配原则了  
隐式补全条件：

- 需要为联合索引
- 不能跨表
- 不能使用GROUP BY 和 DISTINCT
- 索引需要覆盖查询的值，不能回表
- 条件必须为常量，INT()运算符也算

```mysql
# 新特性index(a,b)
EXPLAIN
select a, b
from table
where b = 2;
# a基数较小时，会补全a，例如a = 1 ，a = 2......
EXPLAIN
select a, b
from table
where a = 1
  and b = 2;
```

### 在 MySQL 中建索引时需要注意哪些事项？（简单）

1. 合理的选择某些字段加入索引，索引并不是越多越好。索引会占用空间。
2. **大量重复**的字段不需要添加索引，因为这对于查询并没有帮助，不能筛选掉很多数据。（除非某些字段可以过滤掉大部分数据）
3. **频繁更新**的字段不建议添加索引，因为更新索引需要消耗资源。
4. **字段长度较长**的字段不建议添加索引，因为索引会占用更多的空间。
5. 对于频繁查找的字段可以适当加入索引，如果多个条件经常一起查询，可以优先考虑**联合索引**
6. 对于需要排序、分组、去重的字段可以考虑添加索引，索引可以帮助加快操作速度

### MySQL 中的回表是什么？（中等)）

回表指的是根据"二级索引"作为条件去查询数据时，由于二级索引存储的只有`索引值`和`主键值`。
为了拿到查询的其他数据，需要根据主键去聚簇索引查找完整的数据，这个过程叫做`回表`。

回表会消耗大量的IO，所以尽量减少回表，可以使用覆盖索引，即查询的字段都在索引中，这样就不需要回表了。

```mysql
# index(age)
SELECT *
FROM student
WHERE age = 20; # 回表
```

以上sql语句会造成回表，且会存在`随机IO`，因为age值在当前索引中是有序的，他的id是无序的，
如果age=20数据较多的话，会去主键索引频繁查询。

### MySQL 中使用索引一定有效吗？如何排查索引效果？（中等）

**不一定生效，索引并不是万能的，以下情况可能会导致索引失效：**

- 使用了联合索引但不符合最左匹配原则
- 索引条件中使用了函数、运算符、类型转换等操作
- like查询使用了通配符开头，例如：“%张”，该条件索引不会生效。占位符放在了最左边
- 使用or连接多个条件，如果or连接的条件中有一个没有索引，那么索引不会生效
- order by操作如果排序的字段没有索引，那么索引不会生效
- in查询如果in的值过多，索引不会生效。因为可能会退化为全表扫描

**排查索引效果关键字：** `EXPLAIN`

```mysql
EXPLAIN
SELECT *
FROM `user`
WHERE userAccount = "zhansan"
```

![img.png](picture/img.png)
**核心字段**：

| 字段名  | 描述                                       |   
|:-----|:-----------------------------------------|    
| type | 表的连接类型                                   |   
| key  | 显示 MySQL 实际使用的索引。如果为 NULL，则没有使用索引查询      |  
| rows | 根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好 | 

**type字段** - 速度: system > const > eq_ref > ref > range > index > ALL

| 连接类型   | 描述      |
|:-------|:--------|
| ALL    | 全表扫描    |
| index  | 全索引扫描   |
| range  | 索引范围扫描  |
| ref    | 非唯一索引扫描 |
| eq_ref | 唯一索引扫描  |
| const  | 常量扫描    |
| system | 系统表扫描   |

### MySQL 中的索引数量是否越多越好？为什么？（中等）

回答：不一定，从以下两个角度来分析

- 在空间上： 索引会占用额外的存储空间，索引越多，占用的存储空间越大。（每次建立个新索引，都需要构建一个新的B+树，（默认一页数据页只有16KB）当数据量大，且索引数量多，则会占用大量空间）
- 在时间上： 每次插入、删除、更新数据时，都需要维护索引，索引越多，维护索引的时间越长。（B+树可能会存在**页分裂**、**合并**
  等操作，这会加大时间开销）
    - ps: MySQL存在**查询优化器**
      ，会根据SQL语句分析，选择最优路线，如果索引过多，可能会导致优化器选择耗时更长（想想如果你有很多选择，不是更应该好好考虑，做出最好的选择吗？）。甚至可能因为数据不准确导致选择错误

### 如何使用 MySQL 的 EXPLAIN 语句进行查询分析？（中等）

EXPLAIN 语句用于分析 SQL 查询的执行计划，可以帮助我们了解 MySQL 是如何执行查询的，从而优化查询性能。

**MySQL EXPLAIN 输出字段说明**

| 字段名             | 作用描述                                                                                                                                                                                 |
|-----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| id              | 查询的标识符。相同`id`表示同一执行层级；不同`id`按从大到小顺序执行，`id`为`NULL`表示结果集合并（如UNION）。                                                                                                                    |
| **select_type** | 查询类型。常见值：<br>- `SIMPLE`（简单查询，无子查询或UNION）<br>- `PRIMARY`（外层查询）<br>- `SUBQUERY`（子查询）<br>- `DERIVED`（派生表）<br>- `UNION`（UNION中的第二个或后续查询）。                                                |
| table           | 当前行操作的表名。可能为`<derivedN>`（派生表）或`<unionM,N>`（UNION结果）等。                                                                                                                                |
| partitions      | 匹配的分区（仅当表使用分区时显示）。                                                                                                                                                                   |
| **type**        | **访问类型**（性能关键指标，按最优→最差排序）：<br>- `system`（表仅一行）<br>- `const`（通过主键/唯一索引查找）<br>- `eq_ref`（JOIN时使用主键/唯一索引）<br>- `ref`（非唯一索引查找）<br>- `range`（索引范围扫描）<br>- `index`（全索引扫描）<br>- `ALL`（全表扫描） |
| possible_keys   | 可能使用的索引列表（若为`NULL`，表示无可用索引）。                                                                                                                                                         |
| **key**         | 实际选择的索引（若为`NULL`，表示未使用索引）。                                                                                                                                                           |
| key_len         | 使用的索引长度（字节数）。联合索引中实际使用的部分长度。                                                                                                                                                         |
| ref             | 与索引比较的列或常量（`const`表示常量值，列名表示关联的列）。                                                                                                                                                   |
| **rows**        | **预估**需要扫描的行数（基于统计信息，可能不准确）。                                                                                                                                                         |
| filtered        | 过滤后剩余行的百分比（仅限WHERE/JOIN条件过滤后的比例）。例如，`100`表示未过滤。                                                                                                                                      |
| **Extra**       | 附加信息（常见值）：<br>- `Using where`（使用WHERE过滤）<br>- `Using index`（覆盖索引）<br>- `Using temporary`（使用临时表）<br>- `Using filesort`（使用外部排序）                                                        |

说明：

1. **type** 是优化关键，应尽量避免 `ALL`（全表扫描）。
2. **rows** 和 **filtered** 帮助判断查询效率，值越小越好。
3. **Extra** 字段中若出现 `Using filesort` 或 `Using temporary`，可能需要优化索引或查询结构。

**MySQL EXPLAIN `type` 字段详解**

| 类型值             | 描述                                                                 | 优化建议                                 |
|-----------------|--------------------------------------------------------------------|--------------------------------------|
| **system**      | 表仅有一行数据（系统表或衍生表仅返回一行）。                                             | 无需优化                                 |
| **const**       | 通过**主键或唯一索引**直接匹配一行数据（如 `WHERE id = 1`）。                           | 确保使用主键或唯一索引                          |
| **eq_ref**      | **JOIN操作中**，使用主键或唯一索引进行等值匹配（常见于多表关联的主键匹配）。                         | 检查关联条件是否使用主键/唯一索引                    |
| **ref**         | 使用**非唯一索引**进行等值匹配，可能返回多行（如 `WHERE name = 'John'`，name有普通索引）。       | 考虑索引覆盖或优化查询条件减少匹配行数                  |
| **fulltext**    | 使用全文索引进行搜索（仅限FULLTEXT索引）。                                          | 确保全文索引合理配置                           |
| **ref_or_null** | 类似`ref`，但额外包含对`NULL`值的搜索（如 `WHERE name = 'John' OR name IS NULL`）。 | 避免频繁使用`OR IS NULL`条件                 |
| **index_merge** | 使用多个索引合并结果（如对多个列分别使用索引后合并）。                                        | 检查是否可通过复合索引优化                        |
| **range**       | 使用索引进行范围扫描（如 `WHERE age > 20`，`BETWEEN`，`IN`等）。                    | 确保范围查询的列有索引，避免大范围扫描                  |
| **index**       | **全索引扫描**（遍历索引树的所有叶子节点，但无需回表）。                                     | 检查是否真正需要全索引数据，或尝试覆盖索引（`Using index`） |
| **ALL**         | **全表扫描**（未使用索引，逐行读取数据）。                                            | 必须优化：为查询条件添加索引，或重构查询逻辑               |

补充说明：

1. **性能等级**：从 `system`（最快）到 `ALL`（最慢），性能依次降低。
2. **常见优化场景**：
    - 避免 `ALL`：优先为WHERE条件、JOIN条件的列添加索引。
    - 避免 `index`：若`Extra`字段未出现`Using index`，说明需要回表查询数据，可尝试覆盖索引。
3. **特殊类型**：
    - `index_merge`：可能暗示索引设计不合理，优先考虑复合索引。
    - `ref_or_null`：会导致索引统计不准确，建议用`COALESCE()`函数改写查询。

---

### MySQL 中如何进行 SQL 调优？（中等）

通过 `EXPLAIN` 命令查看查询计划，了解索引使用情况、扫描行数等。（查看是否合理的建立索引以及判断索引是否失效）

1. 用联合索引进行索引覆盖，避免回表操作
2. 尽量避免使用函数、运算符、类型转换等操作导致索引失效
3. 避免使用 `%LIKE` 模糊查询
4. 联合索引需要注意最左匹配原则
5. 业务中需要什么字段则查询什么字段，避免使用`SELECT *`
6. 连表查询中要注意不同字段的字符集是否一致(不一致可能会进行函数操作转换字符集)，否则会`全表扫描`
7. 避免对无索引字段进行排序
8. 可使用 缓存 来缓解数据库压力

可使用MySQL自带的日志，可以把慢SQL记录到日志中

```mysql
-- 查看慢查询日志是否开启以及存储路径
show variables like '%slow_query_log%';
-- 开启慢查询日志
set global slow_query_log = 'ON';
-- 查看慢查询日志的阈值
show variables like 'long_query_time';
-- 设置慢查询日志的阈值(设置阈值为1)
set global long_query_time = 1;
```

---

### MySQL 中 varchar 和 char 有什么区别？（简单）

1. **存储方式**：
    - `char`：固定长度（如果值小于定义的长度，则会用空格补全）
    - `varchar`：可变长度（不会空格补全）。
2. **存储空间**：
    - `char`：固定长度，存储空间固定。
    - `varchar`：可变长度，存储空间根据实际数据长度变化。（最大行长度为65535字节，支持最大长度为65533，如果为Null，则为65532）
        - 如果允许为null，需要1字节标记null列表（如果为空，则还需要在占据1字节）
        - 需要额外空间存储实际字符长度（一般1-2字节，实际长度>255，则需要2字节）
3. **性能**：
    - `char`：固定长度，可能存在浪费部分空间。（不需要记录额外长度，某些情况下效率更快）
    - `varchar`：可变长度，节省存储空间。（需要记录额外长度信息）
4. **适用场景**：
    - `char`：适合存储长度固定、字符集较小的数据（如性别、国家代码等）。
    - `varchar`：适合存储长度可变、字符集较大的数据（如姓名、地址等）。

### MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？（简单）

1. **count(*)**： 统计表中的总行数，包括NULL值。
2. **count(1)**： 约等于count(*)，统计表中的总行数，包括NULL值。
3. **count(字段名)**： 统计该字段中非NULL的值的数量。（字段有索引则走索引，没有则全表扫描）

### 请详细描述 MySQL 的 B+ 树中查询数据的全过程（困难）

B+ 树是一种自平衡的树形数据结构。B+ 树的查询过程可以分为以下几个步骤：

1. **查找根节点**：从根节点开始查找，根节点是 B+ 树的入口点。
2. **查找中间节点**：根据键值和节点中存储的索引键值作比较，判断落入哪个中间节点，依次类推，直到落入叶子节点
3. **查找叶子节点**：在叶子节点中，存储了实际的数据记录，因为一页大小默认16KB，数据不止一条，
4. **查找数据**：数据被分成了多个`组`，其中根据`页目录`来作为索引（类似书目录），页目录分为了多个`槽点`，每个槽点指向一个
   `分组的最大值`。
   根据二分搜索选择槽点，在根据槽点的最大值来不断缩小`双指针`，最后从左指针指向的分组索引值开始遍历即可

---

### MySQL 中的日志类型有哪些？binlog、redo log 和 undo log 的作用和区别是什么？（中等）

回答：MySQL包括了binlog、redo log、 undo log三种日志类型，它们的作用和区别如下：

1. binlog 是二进制文件，记录所有的DDL和DML语句（不记录查询语句）（在事务提交后才会生成binlog）（记录的时SQL语句）
2. undo log 是回滚日志，把操作记录写入磁盘，当需要回滚时重新释放undo log
3. redo log
   是恢复日志，用于保证数据的一致性和持久性。当MySQL发生修改时，会记录这些操作并写入磁盘中，如果服务器发生了宕机，则会释放恢复数据(
   记录的数据页的修改)

### MySQL 是如何实现事务的？（困难）

1. MySQL通过加**锁机制**，使用事务并发修改的控制，来实现事务的隔离性
2. **redo log**：恢复日志，记录对数据库的修改，当服务宕机时重新释放，实现事务的持久性
3. **undo log**：回滚日志，记录事务的反向操作，用于事务回滚，实现了事务的原子性和隔离性
4. **MVCC**：多版本并发控制，满足非锁定读下，提高了并发度，实现了**读已提交**和**可重复读**两种隔离级别，实现事务的隔离性

### MySQL 中的 MVCC 是什么？(困难)

MVCC：多版本并发控制，它是一种**并发控制机制**，允许多个事务同时进行读写操作，不会出现阻塞。每个事务都会创建一个`数据快照`，
每当数据被修改时，并不会直接把旧数据覆盖，而是在索引上记录**最新的版本**，并且索引键上存在隐藏字段`trx_id`(当前事务的id)和
`roll_pointer`(指向undo log指针)
因为我们开启事务后每次修改都有在undo log中记录（`undo log日志记录反向操作`），而索引键上可以指向上一步操作记录的指针。所以这一串串的好像有多个版本连接在一起，所以也叫
`版本链`

#### 怎么判断应该读取哪个版本

这里需要引入一个`read_view`的概念，表示当前事务能够看到的数据版本。`read_view`中包含了以下几个字段：
**事务id具有单调递增性**

- `creator_trx_id`：当前事务id
- `m_ids`：当前活跃的事务id列表（开启了事务，但还没有提交的事务id列表）
- `min_trx_id`：当前最小活跃事务id
- `max_trx_id`：当前最大事务id (系统分配的下一个事务id)

**判断：** 当有个SQL查询语句，会根据查询到的索引中的`trx_id`（事务id）做对比，来判断是否为当前版本。

1. 如果`trx_id`等于`creator_trx_id`，说明这个版本是当前事务自己修改的，可以访问
2. 如果`trx_id` < `min_trx_id`，说明这个版本在当前事务开始前就已经提交了，可以访问
3. 如果`trx_id` > `max_trx_id`，说明这个版本在当前事务开始后才开始的事务，不可访问
4. 如果`trx_id`在`min_trx_id`和`creator_trx_id`之间，
   在`m_ids`中查找，如果存在，则说明这个版本在当前事务开始时还没有提交，不可访问，
   如果不存在，则说明这个版本在当前事务开始时已经提交了，可以访问

#### RC(读已提交)和RR(可重复读)隔离级别？

- **RC(读已提交)**：每次查询都会创建一个`read_view`，所以每次查询看到的都是最新数据
- **RR(可重复读)**：在事务开始时创建一个`read_view`，所以事务中每次查询看到的数据都是一样的，即使有其他事务提交了修改（因为看到数据都一样，所以叫可重复）

#### 什么是当前读和快照读

- **当前读**：读取的是最新数据，会加锁，如`select ... lock in share mode`、`select ... for update`、`insert`、`update`、
  `delete`
- **快照读**：读取的是历史数据，不加锁，如`select ...`（不加锁）

#### 什么是幻读？（一般讨论的是RR情况下）

幻读：在一个事务中，多次查询时，返回的数据行数不一致，即多出了一些数据行。   
在RR隔离级别下，通过MVCC机制，可以避免**大部分幻读**的发生。以下情况仍然会幻读：

- 当`事务一`查询数据进行的是快照读，当`事务二`插入一个新的数据并提交，对`事务一`的新增数据进行修改，再进行查询则会出现`幻读`
- 当`事务一`查询数据进行的是快照读，当`事务二`插入一个新的数据并提交，`事务一`使用当前读查询后出现幻读

---

### MySQL 中的事务隔离级别有哪些？（简单）

- **读未提交**：是隔离级别最低的，允许读取未提交的数据，会出现脏读、不可重复读、幻读等情况。
- **读已提交**：只允许读取已经提交的数据，可以避免脏读，但会出现不可重复读、幻读等情况。（一般讨论幻读是指RR级别下的，因为RC的性质就是可以读取到已提交的数据）
- **可重复读**：保证在一个事务中多次读取的数据是一致的，可以避免脏读和不可重复读，但会出现幻读的情况。(MySQL的默认隔离级别)
- **串行化**：事务串行化执行，可以避免脏读、不可重复读、幻读等情况。因为保证了事务之间操作结果会按顺序执行，所以会严重影响性能。

### MySQL 默认的事务隔离级别是什么？为什么选择这个级别？（简单）

MySQL 默认的事务隔离级别是**可重复读**。原因：为了兼容早期的binlog日志的Statement格式，
因为Statement格式下，binlog记录的是SQL语句，如果使用可重复读，那么在binlog中记录的SQL语句执行时，可以保证数据的一致性。

**如果使用读已提交会出现什么情况呢？**

```mysql
-- 事务一
begin;
delete
from user
where age < 20;

-- 事务二
begin;
insert into user (name, age)
values ('张三', 18);
commit;

commit
# 先提交事务二，再提交事务一
# 则在RC级别下，事务二的数据会保留
```

binlog写入sql的顺序则会按照先提交事务的顺序写入，binlog先记录了事务二的反向sql，再写入事务一的反向sql。这样在主从复制中会出现数据不一致的情况

### 数据库的脏读、不可重复读和幻读分别是什么？（中等）

- **脏读**：一个事务读取了另一个事务未提交的数据，如果另一个事务回滚，那么读取的数据就是无效的，这种情况称为脏读。
- **不可重复读**：一个事务在读取数据时，另一个事务修改了数据并提交，导致该事务再次读取数据时，数据发生了变化，这种情况称为不可重复读。（指的是修改）
- **幻读**：一个事务在读取数据时，另一个事务插入了新的数据并提交，导致该事务再次读取数据时，数据行数发生了变化，这种情况称为幻读。（指的是插入）

---

### MySQL 中有哪些锁类型？（中等）

- 行级锁：对特定的行加锁，允许其他事务访问其他行，适用于高并发场景
- 表级锁：对整个表加锁，不允许其他事务的`读写`操作，适用于保证完整性的小表
- 意向锁：表锁，对事务已上锁的数据有想法，意向锁又分为以下两种，用于行锁和表锁的结合
    - 意向共享锁（IS）：事务想要获取表中某行的共享锁，如果某个事务加了共享锁(S)，则会在表上先加上意向共享锁（IS），表示表里面存在S锁
    - 意向排他锁（IX）：事务想要获取表中某行的排他锁，如果某个事务加了排他锁(X)，则会在表上先加上意向排他锁（IX），表示表里面存在X锁
- 共享锁（S）：允许其他事务读取数据，但不允许修改数据
- 排他锁（X）：不允许其他事务读取或修改数据

| 锁类型 | S   | X  | IS   | IX   |
|-----|-----|----|------|------|
| S   | 不冲突 | 冲突 | 不冲突  | 冲突   |
| X   | 冲突  | 冲突 | 冲突   | 冲突   |
| IS  | 不冲突 | 冲突 | 不冲突  | 不冲突  |
| IX  | 冲突  | 冲突 | 不 冲突 | 不 冲突 | 

- 元数据锁：用来保护数据库对象的元数据（在进行DDL时不可修改表对象）
- 间隙锁：锁的是行与行之间的间隙，防止幻读 （数据记录， age = 18，age = 22，则间隙锁锁的是18和20之间的间隙）（18, 22）
- 临键锁：行锁和间隙锁的结合，锁的是数据行和行与行之间的间隙，防止幻读，锁的区间左闭右开 （18, 22]
- 插入意向锁： 当一个事务上锁时，其他事务有插入数据的想法，则会上个插入意向锁，他是个等待锁，允许和其他插入意向锁一起等待，不过插入数据的时候会阻止其他排他锁
- 自增锁：在插入数据时，如果表中有自增字段，则会在表上加上自增锁，防止其他事务插入数据导致自增值冲突，有以下三种配置模式
    - 配置值：0。 只用Auto-Inc Lock，他是在表上加的锁，只有等自增完数据才会释放
    - 配置值：1（默认配置）Auto-Inc Lock + 互斥量。互斥量可以进行加减累加操作，在语句插入的时候获取到递增值，然后释放锁。在知道插入多少行时用互斥量，不知道插入多少行用Auto-Inc
      Lock
    - 配置值：2。只用互斥量
- 谓词锁：用于空间数据

### MySQL 事务的二阶段提交是什么？（中等）

二阶段提交：事务提交时，分为两个阶段，第一个阶段是准备阶段，第二个阶段是提交阶段。主要要为了确保redo log
和binlog两个日志之间的一致性。通过二阶段提交
来保证在宕机恢复后，不会出现**数据丢失**和**数据不一致**的情况

- **准备阶段**：InnoDB引擎（引擎层）写redo log，并标记状态为prepare，事务处于预提交状态，但没有提交
- **提交阶段**：MySQL服务（业务层）写binlog，如果成功，MySQL通知InnoDB 把redo log状态改为commit，事务提交成功

#### 为什么需要二阶段提交

假设出现的两种情况：

1. redo log处于准备阶段，binlog还没写入，服务宕机：
    - 恢复后，因为redo log未提交。所以redo log记录的数据不算数，binlog没有写入，所以数据一致
2. redo log处于提交阶段，binlog写入，但是redo状态还没修改为commit，服务宕机：
    - 恢复后，因为binlog已经写入，所以redo log也有记录，需要判断两个数据是否一致，一致则提交事务，改为commit。不一致的话，事务回滚
      判断两个文件的一致性：两个文件都存在XID(内部事务的id)，从redo log中获取XID去 binlog 查询，有对应数据则 提交事务， 否则回滚

### MySQL 中如果发生死锁应该如何解决？（中等）

1. 自动检测和回滚
    - MySQL有检测死锁机制，当发现死锁，会回滚掉锁住资源较少的事务
    - 如果一个事务在等待锁的时间超过阈值，也会自动回滚事务
2. 手动处理，通过kill掉某个事务来解决死锁

## 避免死锁

1. 尽量使用低粒度的锁，比如行锁，而不是表锁
2. 尽量避免大事务，大事务占锁时间长，应将大事务拆分为各个小事务
3. 建立合适的索引（同第一点，因为命中索引后锁的是行）
4. 开启死锁检测，适当调整锁等待时间
5. 可以更改隔离级别（RR级别默认有间隙锁和临键锁）
6. 调整申请锁顺序。（先获取影响范围大锁，例如先排他锁，再共享）

```mysql
-- 查看死锁
show engine innodb status;
-- 查看锁等待时间
show variables like 'innodb_lock_wait_timeout';
-- 设置锁等待时间
set innodb_lock_wait_timeout = 10;
-- 查看死锁检测
show variables like 'innodb_deadlock_detect';
-- 设置死锁检测
set innodb_deadlock_detect = on;

-- 查看锁
select *
from information_schema.innodb_locks; -- 当前锁信息
select *
from information_schema.innodb_lock_waits;
-- 锁等待信息

-- innodb_trx -- 查询事务123456指定信息
SELECT trx_state, trx_started, trx_mysql_thread_id, trx_query, trx_id
FROM INFORMATION_SCHEMA.INNODB_TRX
WHERE trx_id = '123456';
```

---

### MySQL 中如何解决深度分页的问题？（中等）

什么是深度分页呢？ 深度分页指的是在大数据量的情况，按照分页的方式访问比较后面的数据。因为数据量较大，当我需要很后面的数据，这样需要一次扫描前面的数据才行，影响性能。
优化深度分页：

1. 可以利用子查询：例如先根据子查询来查出第9000W个数据的id，然后父sql查询该 id 后 的每页大小（例如每页10个数据，则sql为
   limit 10）
    - 优化的核心是利用了索引，直接定位到了起点，再遍历Limit个记录即可。同时也因为不需要扫描每个数据行的数据
2. 记录起点：根据第一点提示，每次分页的时候返回最大id，下次查询的时候带上最大id，则不需要扫描前面的数据。但是这种只**适用于连续查询
   **的情况
3. 用ES搜索引擎解决，（ES也存在深度分页问题）

### 什么是 MySQL 的主从同步机制？它是如何实现的？（中等）

主从同步机制是一种数据库复制的技术，他是让主数据库的数据同步到从数据库（可以有多个）。

原理：主数据库在提交事务的时候会写入所有的操作到binlog日志中，只要把binlog日志内容推送给从数据库，从数据库重放该日志即可

**主从复制类型**：

- 异步复制：主库提交事务后，不等待从库确认，直接返回给客户端，性能高，但是从库可能没有数据
- 同步复制：主库需要等待所有从库回应（性能低，一般不用）
- 半同步复制：主库提交事务后，等待至少一个从库确认（可以通过设置参数来配置回应从库数量）

**异步复制流程**：

| 客户端      | 主库                                   | 从库                                    |
|----------|--------------------------------------|---------------------------------------|
| 发送提交事务请求 |                                      |                                       |
|          | 接受请求，写入binlog                        |                                       |
|          | 把响应返回客户端，同时dump线程监听到binlog有更新则会向从库推送 |                                       |
|          |                                      | 从库接收到向主库拉取数据，并开启I/O线程向relay log中写入    |
|          |                                      | 从库开启SQL线程，从relay log中读取数据，并执行。返回响应给主库 |

**异步复制存在丢失数据的风险**，如果主库挂了，从库还没同步到数据，从库晋升为主库，则原来数据丢失

**并行复制：** 因为单个SQL线程需要处理大量日志，效率低。导致主从同步延迟
- MySQL 5.6：基于库的并行复制，每个库（schema）有自己的复制线程来并行处理不同的库的写入，如果所有的事务在同一个库中（大部分业务是单库），没什么用
- MySQL 5.7：基于组提交的并行复制，**组提交将多个事务的提交操作合并为批处理**。当多个事务在准备阶段且锁没有冲突，则从库可以多个SQL线程来执行组提交。（主库并发度不高则无法使用组提交，主库SQL执行频率不超过组提交阈值则无法组提交）
- MySQL 8.0：基于WriteSet（写集合）的并行复制，为了提高MySQl5.7中从库的事务回放速度。主库事务串行提交的情况下，主要事务之间没有冲突，从库也会并行回放这些事务（WriteSet是事务更新行 的集合，通过这个集合来判断事务是否冲突）

### 如何处理 MySQL 的主从同步延迟？（中等）
主从同步延迟的原因：
- 主库并发高，从库同步不过来 （可以启用多线程复制，MySQL的并行复制）
- 从库硬件性能低，可以升级硬件
- 从库压力大，可以增加从库数量，分担压力
- 从库太多 （导致同步压力大，需要合理分析分配从库数量）
- 长事务 （尽量避免长事务，减少主库写入压力）
- 网络延迟

常见的解决方法：
- 使用缓存，主库写入后同步到缓存 （存在缓存不一致问题）
- 业务层面：关键业务读写走主库，非关键业务读写分离 （需要分析业务）
- 使用二次查询，从库查不到最后必须取主库查一次，主库压力增大（业务方案）
- 强制要求每次写之后立马读的操作走主库。（代码死板，写入后立马查询绑定在一起都走主库）

---