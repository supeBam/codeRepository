### MySQL 的存储引擎有哪些？它们之间有什么区别？

- InnoDB
- MyISAM
- Memory(数据存储再内存中)
- NDB(大规模分布式应用)
- ...

首先在MySQL5.5.5之后存储引擎默认为InnoDB。

InnoDB 与 MyISAM 的区别

1. **InnoDB支持事务，MyISAM不支持** <br>
   因为第一点特性，MyISAM不适合高并发场景，比较适合查询和插入为主的应用。<br>
   所以:
    - MyISAM适合OLAP(Online AnalyticalProcessing-联机分析处理)，例如数据仓库，博客等。 <br>
    - InnoDB适合OLTP(Online Transaction Processing-联机事务处理)，例如电商，银行等。
2. **InnoDB支持外键，MyISAM不支持** <br>
   因为外键性能较差，所以一般项目不会使用外键，而是使用业务逻辑代码做限制。
3. **InnoDB支持行级锁，MyISAM支持表级锁** <br>
    - InnoDB在没有使用主键作为where条件时，也会锁全表。
4. MyISAM的数据和索引是分开存储的，索引也是压缩的 <br>
    - 他们的索引都是B+树，InnoDB的B+树的叶子节点存储了完整的行数据，MyISAM的索引和数据是分开存储的

### MySQL InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别？

**聚簇索引**

- 表中聚簇索引只能有一个，一般为主键索引
- 主键索引的叶子节点存储了完整的行数据
- 适用于范围查找 （叶子节点中存放了所有的数据，且叶子节点之间是通过双向链表连接的）

**非聚簇索引**

- 表中可以有多个非聚簇索引，一般由普通索引和唯一索引组成
- 非聚簇索引的叶子节点存储了*主键*的值以及所在的*列*值
- 适合快速查找特定的列 （索引中存储了列值）

拓展：B+树，在InnoDB中，默认的实现方式为B+树，叶子节点存储了完整的行数据，而MyISAM的B+树叶子节点存储的是数据的地址。<br>

为什么需要使用B+树呢？ <br>
推理过程文章原文：<https://cloud.tencent.com/developer/article/1681803>
推理过程：

1. 当我们查询数据发现查询结果顺序并不是由按照插入顺序决定的，而是根据主键进行了排序。排序的目的是为了当我们根据主键查询时，
   按照顺序查到需要的结果后，不需要继续往后查询了。
2. 执行某个查询SQL不可能把查询记录一条条的使用IO操作，应该一次性把数据全部放进内存中。MySQL在其中引入了**页**，
   数据都存放在页的数据行中，MySQL中一页的大小为16KB。
3. 为了快速找到准确的页，设计了类似**书签**的标记。
   例如：假设每100页数据插入一个标签，当需要查第3456页就知道在第34个标签那。

MySQL 页结构讲解可以看看：
<https://www.bilibili.com/video/BV1pG4y1o7n3/?spm_id_from=333.337.search-card.all.click&vd_source=d40e64c746feefc8c24cdf263d809fa3>

### MySQL的索引类型

从数据结构来看，可以分为：

- B+树索引
    - MySQL默认的索引类型，树型结构，叶子节点双向链表，可以范围查询
- Hash索引
    - 哈希表结构，查询速度快，不支持范围查询，且不存储数据顺序
- R树索引
    - 适用于空间查询，常用于存储GIS系统的空间数据
- 倒排索引
    - 用于存储单词与文档之间的映射关系，可以模糊匹配和关键字搜索

从InnoDB存储引擎的索引类型来看，可以分为：

- 聚簇索引
    - 叶子节点存储了完整的行数据
- 非聚簇索引
    - 叶子节点存储了主键的值以及所在的列值。可以有多个

从索引性质来看，可以分为：

- 主键索引
    - 表中的主键索引只能有一个，不能为null
- 普通索引
    - 索引值可以重复，且可以有多个
- 唯一索引
    - 索引值唯一，但索引值可以有多个null
- 联合索引
    - 多个列组成的索引，联合索引的查询顺序与索引列的顺序有关
- 全文索引
    - 用于全文搜索，适用于对文本内容进行复杂的查询
- 空间索引
    - 适用于多维数据查询，例如区域查询和最近距离查询

### 为什么MySQL选择使用B+树作为索引结构？

数据库中B+树的特点：

- B+树是一棵多叉树，随着数据量的变大，树的高度增长速度不会像其他二叉树一样那么快，维持了比较矮且胖的性质。
  非叶子节点存储的都是**索引**和**页指针**，使得页的空间更大，可以存储更多的记录。
- B+树是一棵自平衡树，根节点到各个叶子节点的长度相同，并且在插入和删除的时候会进行分裂和合并操作，维持树的平衡。
  他又会有冗余节点，使得在删除的时候让树结构变化小。
- B+树叶子节点之间是通过双向链表连接的，可以快速进行范围查询。

### B树和B+树的区别

- 相同点
    - 他们都是平衡树，且都为多叉树
- 不同点
    - B树
        - 每个节点都存的都是完整的数据
        - 因为数据都在各个节点中，当范围查找时，每次都需要从根遍历
        - B树查询时间不稳定，因为数据在某个节点上
    - B+树
        - 非叶子节点存储的是索引和页指针，叶子节点存储了完整的数据（因此内存中可以存放更多的索引页）
        - 因为数据都在叶子节点上，且叶子节点是双向链表连接。范围查找效率更快
        - 查询时间稳定、平均。因为数据都在叶子节点上，需要从根查到叶

### 为什么InnoDB B+树中同层的非叶子节点之间也存在双链表? （拓展）

执行一个sql语句

```sql
select *
from table
where a < index1
  and index1 < b
  and index2 > c
  and index2 < d;
-- 这段sql里有两个独立索引，一个index1，一个index2 
```

**问题一：MySQL会选择使用哪个索引呢？**<br>
结论：哪个索引区分大，筛选更快就用哪个。假如使用 index1 能选出 n 条记录，使用 index2 能选出 m 条记录，如果 n <
m，则使用index1<br><br>
**问题二：MySQL是怎么判断 n < m 呢？** <br>
假设 n 和 m 分别代表叶子节点的数，正常来想应该是找到第一个值所在的叶子节点，然后向后遍历 n 次。但是如果n和m数据量较大，这样比较费时。
假设 n < m， 我们都知道每个数据页自己有多少个数据，假设每个数据页有 avg 个数据。他们分别用了 y1、y2 个数据页。
那么 n = y1 * avg， m = y2 * avg，数据页其实可以估算大小，假设 n、m 数据量非常大。假设有 k 层，可以从k-1获取页数或则更上层。
这样就可以加载更少的节点来推算n、m的大小了，这也是为什么同层的非叶子节点是双向链表<br>
原文来自：<https://www.zhihu.com/question/478187330/answer/2050494617>

### MySQL 三层 B+ 树能存多少数据？

MySQL的InnoDB中，默认数据页大小为 **16KB** <br>
**基本参数**<br>
每个非叶子节点里只存储了**指针**和**索引值**，假设每个数据记录的主键和数据大小总共为 **1KB**(实际更小)，
每个叶节点的大小为16KB<br><br>
**计算**

- 叶子节点：每个叶子节点可以存放 **16** 条记录 (16 KB / 1 KB )
- 第二层：每个指针的大小为 **6字节**，索引键为 **8字节**，所以每个节点可以存放 **1170** 个叶子节点 (16 * 1024 / (6 + 8) )
- 根节点：每个节点可以有**1170**个子节点
- 总记录数：叶子节点 * 第二层节点 * 根节点 = 1170 * 1170 * 16 = 21902400 （约等于2千万条）

ps：默认一页大小为16KB，可以通过 `innodb_page_size` 修改大小。操作系统中有`连续读`和`缓冲数据`
的原理，所以进行IO读取时，会连续的读取4KB的数据，所以页大小通常设为4,8,16KB(4的倍数)


### MySQL 索引的最左前缀匹配原则是什么？
最左前缀匹配原则是指在创建联合索引时，索引的顺序与查询条件中的列的顺序一致，
且查询条件中的列必须包含联合索引中的最左边的列。顺序由左到右，依此类推。

**原理：** 联合索引在B+树中是按照索引列的顺序进行排序的，所以最左前缀匹配原则可以有效地利用索引，提高查询效率。

**索引下推：** 在MySQL5.6以后推出索引下推，他是一种可以减少回表的技术，用于`联合索引`上，它可以把一些查询条件下推到引擎层完成判断。不再像之前
那样，先查到数据，再回到Sever层进行判断。
```mysql
# 索引下推index(a,b,c)
select a,b,c from table where a = 1  and c = 3
``` 

**MySQL8.0.13新特性：**在使用联合索引时，当a的基数较小时，他会自己补全a的查询条件，这样就符合最左匹配原则了  
隐式补全条件：
- 需要为联合索引
- 不能跨表
- 不能使用GROUP BY 和 DISTINCT
- 索引需要覆盖查询的值，不能回表
- 条件必须为常量，INT()运算符也算
```mysql
# 新特性index(a,b)
EXPLAIN select a,b from table where  b = 2;
# a基数较小时，会补全a，例如a = 1 ，a = 2......
EXPLAIN select a,b from table where a = 1 and b = 2;
```

### 在 MySQL 中建索引时需要注意哪些事项？（简单）
1. 合理的选择某些字段加入索引，索引并不是越多越好。索引会占用空间。
2. **大量重复**的字段不需要添加索引，因为这对于查询并没有帮助，不能筛选掉很多数据。（除非某些字段可以过滤掉大部分数据）
3. **频繁更新**的字段不建议添加索引，因为更新索引需要消耗资源。
4. **字段长度较长**的字段不建议添加索引，因为索引会占用更多的空间。
5. 对于频繁查找的字段可以适当加入索引，如果多个条件经常一起查询，可以优先考虑**联合索引**
6. 对于需要排序、分组、去重的字段可以考虑添加索引，索引可以帮助加快操作速度

